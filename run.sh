#!/usr/bin/env bash

set -o errexit

ROOT_DIR=$(cd "$(dirname -- "${BASH_SOURCE[0]}")" && pwd)
RUN_SCRIPT="./$(basename -- "${BASH_SOURCE[0]}")"

cd "${ROOT_DIR}"
DEFAULT_THUNDERBLADE_AGENTS_DIR=$(cd ../thunderblade_agents/heuristic && pwd)

export ORCHESTRATOR_HOST=localhost
export ORCHESTRATOR_PORT=9000
export SERVICE_DISCOVERY_HOST=localhost
export SERVICE_DISCOVERY_PORT=9010
export PYTHON_SERVICES_HOST=localhost
export PYTHON_SERVICES_PORT=9001
export WEB_PROXY_HOST=localhost
export WEB_PROXY_PORT=8080
export COGMENT_VERSION=2.2.0-rc3

if [[ "$1" == "python_services_build" ]]; then
  "${RUN_SCRIPT}" _py_build python_services

elif [[ "$1" == "python_services_start" ]]; then
  "${RUN_SCRIPT}" _py_start python_services

elif [[ "$1" == "agents_build" ]]; then
  if [[ -z "${THUNDERBLADE_AGENTS_DIR}" ]]; then
    THUNDERBLADE_AGENTS_DIR="${DEFAULT_THUNDERBLADE_AGENTS_DIR}"
    printf "** Using default value '%s' for the thunderblade agents directory, set THUNDERBLADE_AGENTS_DIR to specify another one\n" "${THUNDERBLADE_AGENTS_DIR}"
  fi
  "${RUN_SCRIPT}" _py_build "${THUNDERBLADE_AGENTS_DIR}"

elif [[ "$1" == "agents_start" ]]; then
  if [[ -z "${THUNDERBLADE_AGENTS_DIR}" ]]; then
    THUNDERBLADE_AGENTS_DIR="${DEFAULT_THUNDERBLADE_AGENTS_DIR}"
    printf "** Using default value '%s' for the thunderblade agents directory, set THUNDERBLADE_AGENTS_DIR to specify another one\n" "${THUNDERBLADE_AGENTS_DIR}"
  fi
  "${RUN_SCRIPT}" _py_start "${THUNDERBLADE_AGENTS_DIR}"

elif [[ "$1" == "cli_build" ]]; then
  "${RUN_SCRIPT}" _py_build cli

elif [[ "$1" == "cli_start" ]]; then
  "${RUN_SCRIPT}" _py_start cli

elif [[ "$1" == "wait_and_cli_start" ]]; then
  sleep 10
  "${RUN_SCRIPT}" cli_start

elif [[ "$1" == "web_client_build" ]]; then
  "${RUN_SCRIPT}" _js_build web_client

elif [[ "$1" == "web_client_start" ]]; then
  "${RUN_SCRIPT}" _js_start web_client

elif [[ "$1" == "cogment_install" ]]; then
  curl --silent -L https://raw.githubusercontent.com/cogment/cogment-cli/main/install.sh | bash -s -- --version "${COGMENT_VERSION}" --skip-install
  if command -v "setrpaths.sh" &>/dev/null; then
    printf "** Compute Canada's 'setrpaths.sh' is available, using it to patch the downloaded version of cogment\n"
    setrpaths.sh --path ./cogment
  fi

elif [[ "$1" == "orchestrator_start" ]]; then
  ./cogment services orchestrator \
    --actor_port="${ORCHESTRATOR_PORT}" \
    --lifecycle_port="${ORCHESTRATOR_PORT}" \
    --actor_http_port="${WEB_PROXY_PORT}" \
    --pre_trial_hooks="grpc://${PYTHON_SERVICES_HOST}:${PYTHON_SERVICES_PORT}"

elif [[ "$1" == "build" ]]; then
  "${RUN_SCRIPT}" cogment_install
  "${RUN_SCRIPT}" python_services_build
  "${RUN_SCRIPT}" agents_build
  "${RUN_SCRIPT}" cli_build
  "${RUN_SCRIPT}" web_client_build

elif [[ "$1" == "python_build" ]]; then
  "${RUN_SCRIPT}" cogment_install
  "${RUN_SCRIPT}" python_services_build
  "${RUN_SCRIPT}" agents_build
  "${RUN_SCRIPT}" cli_build

elif [[ "$1" == "services_start" ]]; then
  "${RUN_SCRIPT}" "_parallel" "python_services_start" "orchestrator_start" "agents_start"

elif [[ "$1" == "start" ]]; then
  "${RUN_SCRIPT}" "_parallel" "python_services_start" "orchestrator_start" "agents_start" "wait_and_cli_start"

elif [[ "$1" == "_py_build" ]]; then
  shift
  directory=$1
  cp data.proto cogment.yaml "${directory}"
  cd "${directory}"
  virtualenv -p python3 .venv
  source .venv/bin/activate
  pip install -r requirements.txt
  .venv/bin/python -m cogment.generate
  deactivate

elif [[ "$1" == "_py_start" ]]; then
  shift
  directory=$1
  cd "${directory}"
  .venv/bin/python main.py

elif [[ "$1" == "_js_build" ]]; then
  shift
  directory=$1
  cp data.proto cogment.yaml "${directory}"
  cd "${directory}"
  npm install
  npx cogment-js-sdk-generate cogment.yaml

elif [[ "$1" == "_js_start" ]]; then
  shift
  directory=$1
  cd "${directory}"
  npm run start

elif [[ "$1" == "_parallel" ]]; then
  shift
  commands=("$@")
  commands_num="${#commands[@]}"

  # Using GNU parallel to launch the provided commands in parallel and properly handle
  # their output and termination.
  #
  # In particular:
  # - When this process ends, the commands will end (default behavior)
  # - When one of the commands fails everything is stopped (`--halt now,fail=1`)
  # - All the output are printed as they are generated by the command (`-u`)
  # - As many jobs as there are provided commands are ran (`-j "${commands_num}"`)
  parallel -j "${commands_num}" -u --halt now,fail=1 "${RUN_SCRIPT}" ::: "${commands[@]}"

else
  echo "Unknown command [$1]"
fi
